---
title: Layouts and Pages
description: Learn how to create your first pages and layouts, and link between them with the Link component.
related:
  title: API Reference
  description: Learn more about the features mentioned in this page by reading the API Reference.
  links:
    - app/getting-started/linking-and-navigating
    - app/api-reference/file-conventions/layout
    - app/api-reference/file-conventions/page
    - app/api-reference/components/link
    - app/api-reference/file-conventions/dynamic-routes
---

Next.js uses **file-system based routing**, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.

## Creating a page

A page is the UI shown for a route (URL). Add a [`page` file](/docs/app/api-reference/file-conventions/page) inside the `app` directory and default export a React component. For example, to create the home page (`/`):

<Image
  alt="page.js special file"
  srcLight="/docs/light/page-special-file.png"
  srcDark="/docs/dark/page-special-file.png"
  width="1600"
  height="282"
/>

```tsx filename="app/page.tsx" switcher
export default function Page() {
  return <h1>Hello Next.js!</h1>
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  return <h1>Hello Next.js!</h1>
}
```

## Creating a layout

Use a layout to share UI across pages. When you navigate between pages that use the same layout, React keeps the layout mounted, so its state persists and only the page content changes.

1. Place a `layout` file in the route segment it should apply to (for example, `app/blog/layout.tsx` applies to everything under `/blog`).
2. Default export a React component. The component should accept a `children` prop which can be a page or another layout.
3. Place `{children}` where you want the page content and nested layouts in that segment to appear.

For example, to create a layout that accepts the index page as a child, add a `layout` file inside the `app` directory:

<Image
  alt="layout.js special file"
  srcLight="/docs/light/layout-special-file.png"
  srcDark="/docs/dark/layout-special-file.png"
  width="1600"
  height="363"
/>

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <header>My App</header>
        <nav>{/* navigation links */}</nav>
        <main>{children}</main>
        <footer>© My Company</footer>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>My App</header>
        <nav>{/* navigation links */}</nav>
        <main>{children}</main>
        <footer>© My Company</footer>
      </body>
    </html>
  )
}
```

The layout above is called a [root layout](/docs/app/api-reference/file-conventions/layout#root-layout) because it is the first layout in the `app` directory tree. The root layout is **required** and must contain `html` and `body` tags.

## Linking between pages

You can use the [`<Link>` component](/docs/app/api-reference/components/link) to navigate between routes. `<Link>` is a built-in Next.js component that extends the HTML `<a>` tag to provide [prefetching](/docs/app/getting-started/linking-and-navigating#prefetching) and [client-side navigation](/docs/app/getting-started/linking-and-navigating#client-side-transitions).

For example, to generate a list of blog posts, import `<Link>` from `next/link` and pass a `href` prop to the component:

```tsx filename="app/ui/post.tsx" highlight={1,10} switcher
import Link from 'next/link'

export default async function Posts() {
  const posts = await getPosts()

  return (
    <>
      <Link href="/blog">Blog</Link>
      <ul>
        {posts.map((post) => (
          <li key={post.slug}>
            <Link href={`/blog/${post.slug}`}>{post.title}</Link>
          </li>
        ))}
      </ul>
    </>
  )
}
```

```jsx filename="app/ui/post.js" highlight={1,10}  switcher
import Link from 'next/link'

export default async function Posts() {
  const posts = await getPosts()

  return (
    <>
      <Link href="/blog">Blog</Link>
      <ul>
        {posts.map((post) => (
          <li key={post.slug}>
            <Link href={`/blog/${post.slug}`}>{post.title}</Link>
          </li>
        ))}
      </ul>
    </>
  )
}
```

> **Good to know**: `<Link>` is the primary way to navigate between routes in Next.js. You can also use the [`useRouter` hook](/docs/app/api-reference/functions/use-router) for more advanced navigation.

## Creating a nested route

A nested route is made of multiple URL segments. For example, the `/blog/[slug]` route has three segments:

- `/` (Root Segment)
- `blog` (Segment)
- `[slug]` (Leaf Segment)

In Next.js:

- **Folders** are used to define the route segments that map to URL segments.
- **Files** (like `page` and `layout`) are used to create UI that is shown for a segment.

Nest folders to create nested routes. For example, to add `/blog`, create a `blog` folder in `app`, then add a `page.tsx` file:

<Image
  alt="File hierarchy showing blog folder and a page.js file"
  srcLight="/docs/light/blog-nested-route.png"
  srcDark="/docs/dark/blog-nested-route.png"
  width="1600"
  height="525"
/>

```tsx filename="app/blog/page.tsx" switcher
export default function Page() {
  return (
    <ul>
      <li>First post</li>
      <li>Second post</li>
    </ul>
  )
}
```

```jsx filename="app/blog/page.js" switcher
export default function Page() {
  return (
    <ul>
      <li>First post</li>
      <li>Second post</li>
    </ul>
  )
}
```

Continue nesting folders to add more routes. For example, to show a specific blog post, create a [dynamic segment](#creating-a-dynamic-segment) folder named `[slug]` inside `blog` and add a `page` file:

<Image
  alt="File hierarchy showing blog folder with a nested slug folder and a page.js file"
  srcLight="/docs/light/blog-post-nested-route.png"
  srcDark="/docs/dark/blog-post-nested-route.png"
  width="1600"
  height="687"
/>

```tsx filename="app/blog/[slug]/page.tsx" switcher
export default function Page() {
  return <h1>Hello, Blog Post Page!</h1>
}
```

```jsx filename="app/blog/[slug]/page.js" switcher
export default function Page() {
  return <h1>Hello, Blog Post Page!</h1>
}
```

## Nesting layouts

By default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their `children` prop. You can nest layouts by adding `layout` inside specific route segments (folders).

For example, to create a layout for the `/blog` route, add a new `layout` file inside the `blog` folder.

<Image
  alt="File hierarchy showing root layout wrapping the blog layout"
  srcLight="/docs/light/nested-layouts.png"
  srcDark="/docs/dark/nested-layouts.png"
  width="1600"
  height="768"
/>

```tsx filename="app/blog/layout.tsx" switcher
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

```jsx filename="app/blog/layout.js" switcher
export default function BlogLayout({ children }) {
  return <section>{children}</section>
}
```

If you were to combine the two layouts above, the root layout (`app/layout.js`) would wrap the blog layout (`app/blog/layout.js`), which would wrap the blog (`app/blog/page.js`) and blog post page (`app/blog/[slug]/page.js`).

## Creating a dynamic segment

[Dynamic segments](/docs/app/api-reference/file-conventions/dynamic-routes) allow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.

To create a dynamic segment, wrap the segment (folder) name in square brackets: `[segmentName]`. For example, in the `app/blog/[slug]/page.tsx` route, the `[slug]` is the dynamic segment.

```tsx filename="app/blog/[slug]/page.tsx" switcher
export default async function BlogPostPage({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  const post = await getPost(slug)

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  )
}
```

```jsx filename="app/blog/[slug]/page.js" switcher
export default async function BlogPostPage({ params }) {
  const { slug } = await params
  const post = await getPost(slug)

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  )
}
```

Learn more about [Dynamic Segments](/docs/app/api-reference/file-conventions/dynamic-routes) and the [`params`](/docs/app/api-reference/file-conventions/page#params-optional) props.

Nested [layouts within Dynamic Segments](/docs/app/api-reference/file-conventions/layout#params-optional) can also access the `params` props.

<details>
<summary>Static generation with `generateStaticParams`</summary>

If you know the list of dynamic params ahead of time, you can statically generate those pages at build time by exporting [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params). For example:

```tsx filename="app/blog/[slug]/page.tsx" switcher
export async function generateStaticParams() {
  const res = await fetch('https://api.vercel.app/blog')
  const posts = await res.json()

  return posts.map((post: { slug: string }) => ({ slug: post.slug }))
}

export default async function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  // fetch and render post for `slug`
}
```

```jsx filename="app/blog/[slug]/page.js" switcher
export async function generateStaticParams() {
  const res = await fetch('https://api.vercel.app/blog')
  const posts = await res.json()

  return posts.map((post) => ({ slug: post.slug }))
}

export default async function Page({ params }) {
  const { slug } = await params
  // fetch and render post for `slug`
}
```

Only the returned params are prerendered. By default, any other params will be generated on demand at request time. To opt out (and return 404 for unknown params), set [`dynamicParams: false`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams).

</details>

## Rendering with search params

When a page's content depends on search parameters (e.g. `?sort=asc`), read them using the [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) prop.

```tsx filename="app/products/page.tsx" switcher
import Link from 'next/link'

export default async function ProductsPage({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const { sort: rawSort } = await searchParams
  const sort = rawSort === 'desc' ? 'desc' : 'asc'

  return (
    <section>
      <header>
        <h1>Products (sorted {sort})</h1>
        <nav>
          <Link href="/products?sort=asc">Sort Asc</Link>
          {' · '}
          <Link href="/products?sort=desc">Sort Desc</Link>
        </nav>
      </header>
      {/* Render products using `sort` */}
    </section>
  )
}
```

```jsx filename="app/products/page.js" switcher
import Link from 'next/link'

export default async function ProductsPage({ searchParams }) {
  const { sort: rawSort } = await searchParams
  const sort = rawSort === 'desc' ? 'desc' : 'asc'

  return (
    <section>
      <header>
        <h1>Products (sorted {sort})</h1>
        <nav>
          <Link href="/products?sort=asc">Sort Asc</Link>
          {' · '}
          <Link href="/products?sort=desc">Sort Desc</Link>
        </nav>
      </header>
      {/* Render products using `sort` */}
    </section>
  )
}
```

When you click the sort links, the URL updates (for example, `/products?sort=desc`) and the **server re-renders** the page with the new `searchParams`, updating the heading and the rendered products accordingly.

<details>
<summary>`searchParams`, dynamic rendering, and `useSearchParams`</summary>

Using `searchParams` in a page opts that route into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering) because the value comes from the incoming request.

- Use the `searchParams` prop when you need search parameters to **load data for the page** (e.g. pagination, filtering from a database).
- Use `useSearchParams` when search parameters are used **only on the client** (e.g. filtering a list already loaded via props). Routes can still be statically rendered when using this hook if its usage is wrapped in a `<Suspense>` boundary. Learn more about working with `useSearchParams` in [static rendering](/docs/app/api-reference/functions/use-search-params#static-rendering) and [dynamic rendering](/docs/app/api-reference/functions/use-search-params#dynamic-rendering).
- As a small optimization, you can use `new URLSearchParams(window.location.search)` in **callbacks** or **event handlers** to read search params without triggering re-renders.

</details>
