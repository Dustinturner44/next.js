---
title: public Folder
nav_title: public
description: Next.js allows you to serve static files, like images, in the public directory. You can learn how it works here.
---

{/* The content of this doc is shared between the app and pages router. You can use the `<PagesOnly>Content</PagesOnly>` component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. */}

Next.js can serve static files, like images, under a folder called `public` in the root directory. Files inside `public` can then be referenced by your code starting from the base URL (`/`).

For example, the file `public/avatars/me.png` can be viewed by visiting the `/avatars/me.png` path. The code to display that image might look like:

```jsx filename="avatar.js"
import Image from 'next/image'

export function Avatar({ id, alt }) {
  return <Image src={`/avatars/${id}.png`} alt={alt} width="64" height="64" />
}

export function AvatarOfMe() {
  return <Avatar id="me" alt="A portrait of me" />
}
```

## Caching

Next.js cannot safely cache assets in the `public` folder because they may change. The default caching headers applied are:

```jsx
Cache-Control: public, max-age=0
```

## Robots, Favicons, and others

<PagesOnly>

The folder is also useful for `robots.txt`, `favicon.ico`, Google Site Verification, and any other static files (including `.html`). But make sure to not have a static file with the same name as a file in the `pages/` directory, as this will result in an error. [Read more](/docs/messages/conflicting-public-file-page).

</PagesOnly>

<AppOnly>

For static metadata files, such as `robots.txt`, `favicon.ico`, etc, you should use [special metadata files](/docs/app/api-reference/file-conventions/metadata) inside the `app` folder.

## Reading from the public folder

If you need to read files from the `public` folder in Route Handlers, Server Components, or Server Functions, avoid using relative paths like `./public/all-posts.json`. Relative paths can break as part of the bundling process.

Instead, resolve paths relative to your project root using `process.cwd()` with `path.join`.

```ts filename="app/post/[id]/route.ts"
import { NextResponse } from 'next/server'
import { readFile } from 'node:fs/promises'
import { join } from 'node:path'

export async function GET(_req: Request, context: RouteContext<'/posts/[id]'>) {
  const filePath = join(process.cwd(), 'public', 'all-posts.json')
  const fileContent = await readFile(filePath, 'utf8')
  const allPosts = JSON.parse(fileContent)

  const { id } = await context.params

  const post = allPosts.find((entry) => entry.id === id)

  if (!post) return NextResponse.json({ error: 'Not found' }, { status: 404 })

  return NextResponse.json({ post })
}
```

```js filename="app/post/[id]/route.js"
import { NextResponse } from 'next/server'
import { readFile } from 'node:fs/promises'
import { join } from 'node:path'

export async function GET(_, context) {
  const filePath = join(process.cwd(), 'public', 'all-posts.json')
  const fileContent = await readFile(filePath, 'utf8')
  const allPosts = JSON.parse(fileContent)

  const { id } = await context.params

  const post = allPosts.find((entry) => entry.id === id)

  if (!post) return NextResponse.json({ error: 'Not found' }, { status: 404 })

  return NextResponse.json({ post })
}
```

## Writing to the public folder

Avoid writing to the filesystem at runtime to create or modify files in `public` (or elsewhere). In many production environments:

- File writes are not persisted (ephemeral filesystems used to serve requests).
- The hosting platform may block write permissions.
- Next.js build outputs and static asset manifests are generated at build time. Files written at runtime are not included and wonâ€™t be served by the static file server.

Prefer storing dynamic data in a database, object storage, or caching layer. If you need to generate assets ahead of time, do so during the build process.

</AppOnly>
