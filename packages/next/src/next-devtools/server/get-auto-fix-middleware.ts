import type { ServerResponse, IncomingMessage } from 'http'
import { middlewareResponse } from './middleware-response'
import { promises as fs } from 'fs'
import path from 'path'

import { generateText } from 'ai'
import { anthropic } from '@ai-sdk/anthropic'

interface AutoFixRequest {
  prompt: string
}

interface AutoFixResponse {
  success: boolean
  fix?: string
  explanation?: string
  error?: string
  appliedChanges?: AppliedChange[]
}

interface AppliedChange {
  file: string
  changes: string
  line?: number
}

export function getAutoFixMiddleware(projectDir: string) {
  return async function (
    req: IncomingMessage,
    res: ServerResponse,
    next: () => void
  ): Promise<void> {
    const { pathname } = new URL(`http://n${req.url}`)

    if (pathname !== '/__nextjs_auto_fix') {
      return next()
    }

    if (req.method !== 'POST') {
      return middlewareResponse.methodNotAllowed(res)
    }

    try {
      // Parse request body
      const body = await parseRequestBody(req)
      const { prompt }: AutoFixRequest = JSON.parse(body)

      if (!prompt || typeof prompt !== 'string') {
        return middlewareResponse.badRequest(res)
      }

      // Call Claude via AI SDK to generate fix
      const result = await generateClaudeFix(prompt, req, projectDir)
      
      return middlewareResponse.json(res, result)
    } catch (error) {
      console.error('Auto fix error:', error)
      const result: AutoFixResponse = {
        success: false,
        error: error instanceof Error ? error.message : 'Auto fix failed'
      }
      return middlewareResponse.json(res, result)
    }
  }
}

async function parseRequestBody(req: IncomingMessage): Promise<string> {
  return new Promise((resolve, reject) => {
    let body = ''
    req.on('data', (chunk) => {
      body += chunk.toString()
    })
    req.on('end', () => {
      resolve(body)
    })
    req.on('error', reject)
  })
}

async function generateClaudeFix(prompt: string, req: IncomingMessage, projectDir: string): Promise<AutoFixResponse> {
  try {
    // Enhanced prompt for Claude to provide actionable fixes
    const enhancedPrompt = `
You are a Next.js expert helping to fix development errors. The user has encountered the following error:

${prompt}

Please analyze the error and provide specific code changes that can be automatically applied. 

IMPORTANT: If the error includes file paths and line numbers, provide exact file modifications. Only suggest changes for files that clearly exist in the error context.

Format your response as JSON with the following structure:
{
  "explanation": "Brief explanation of what's causing the error",
  "fix": "General description of the fix",
  "fileChanges": [
    {
      "file": "relative/path/to/file.js",
      "action": "replace|add|delete",
      "lineNumber": 10,
      "oldCode": "exact code to replace (if action is replace)",
      "newCode": "exact code to insert"
    }
  ]
}

Only include fileChanges if you can identify specific files and exact code changes from the error context. If no specific files can be identified, leave fileChanges as an empty array.

Be concise but thorough. Focus on actionable solutions.
`.trim()

    // Use AI SDK to process the prompt
    const claudeResponse = await callClaudeWithAISDK(enhancedPrompt)
    
    // Apply file changes if any were suggested
    let appliedChanges: AppliedChange[] = []
    if (claudeResponse.fileChanges && claudeResponse.fileChanges.length > 0) {
      appliedChanges = await applyFileChanges(claudeResponse.fileChanges, projectDir)
    }
    
    return {
      success: true,
      fix: claudeResponse.fix,
      explanation: claudeResponse.explanation,
      appliedChanges
    }
  } catch (error) {
    throw new Error(`Claude AI error: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

interface FileChange {
  file: string
  action: 'replace' | 'add' | 'delete'
  lineNumber?: number
  oldCode?: string
  newCode?: string
}

async function callClaudeWithAISDK(prompt: string): Promise<{ fix: string; explanation: string; fileChanges?: FileChange[] }> {
  try {
    // Check for API key
    const apiKey = process.env.ANTHROPIC_API_KEY
    if (!apiKey) {
      console.warn('ANTHROPIC_API_KEY not found. Using fallback response.')
      return getFallbackResponse()
    }

    const result = await generateText({
      model: anthropic('claude-3-haiku-20240307'),
      prompt,
      maxTokens: 1024,
    })

    const content = result.text
    if (!content) {
      throw new Error('No response from Claude')
    }

    // Try to parse as JSON first, fallback to plain text
    try {
      const parsedResponse = JSON.parse(content)
      return {
        fix: parsedResponse.fix || content,
        explanation: parsedResponse.explanation || 'Generated by Claude',
        fileChanges: parsedResponse.fileChanges || []
      }
    } catch {
      // If not JSON, treat as plain text and extract useful parts
      return parseClaudeTextResponse(content)
    }
  } catch (error) {
    console.error('Claude AI SDK call failed:', error)
    return getFallbackResponse()
  }
}

async function applyFileChanges(fileChanges: FileChange[], projectDir: string): Promise<AppliedChange[]> {
  const appliedChanges: AppliedChange[] = []
  
  // Use the passed project directory
  const projectRoot = projectDir
  
  for (const change of fileChanges) {
    try {
      const filePath = path.resolve(projectRoot, change.file)
      
      // Security check: ensure we're not modifying files outside the project
      if (!filePath.startsWith(projectRoot)) {
        console.warn(`Skipping file change outside project root: ${change.file}`)
        continue
      }
      
      // Check if file exists
      try {
        await fs.access(filePath)
      } catch {
        console.warn(`File not found, skipping: ${change.file}`)
        continue
      }
      
      if (change.action === 'replace' && change.oldCode && change.newCode) {
        const fileContent = await fs.readFile(filePath, 'utf8')
        const updatedContent = fileContent.replace(change.oldCode, change.newCode)
        
        if (updatedContent !== fileContent) {
          await fs.writeFile(filePath, updatedContent, 'utf8')
          appliedChanges.push({
            file: change.file,
            changes: `Replaced: ${change.oldCode.slice(0, 50)}... -> ${change.newCode.slice(0, 50)}...`,
            line: change.lineNumber
          })
        }
      }
      // Additional actions (add, delete) can be implemented here
    } catch (error) {
      console.error(`Failed to apply change to ${change.file}:`, error)
    }
  }
  
  return appliedChanges
}

function parseClaudeTextResponse(content: string): { fix: string; explanation: string } {
  // Simple parsing to extract explanation and fix from text response
  const lines = content.split('\n').filter(line => line.trim())
  
  let explanation = ''
  let fix = ''
  let currentSection = 'explanation'
  
  for (const line of lines) {
    const lowerLine = line.toLowerCase()
    if (lowerLine.includes('fix') || lowerLine.includes('solution') || lowerLine.includes('steps')) {
      currentSection = 'fix'
      continue
    }
    
    if (currentSection === 'explanation' && !explanation) {
      explanation = line.trim()
    } else if (currentSection === 'fix') {
      fix += (fix ? '\n' : '') + line.trim()
    }
  }
  
  return {
    explanation: explanation || 'Claude analysis provided',
    fix: fix || content
  }
}

function getFallbackResponse(): { fix: string; explanation: string } {
  return {
    explanation: "Auto-fix service requires ANTHROPIC_API_KEY environment variable to be set. Install AI SDK dependencies: npm install ai @ai-sdk/anthropic",
    fix: "1. Check the error message and stack trace carefully\n2. Verify your code syntax and imports\n3. Check Next.js documentation for similar issues\n4. Restart your development server\n5. Clear Next.js cache with `rm -rf .next`\n\nTo enable AI-powered auto-fix:\n1. Set ANTHROPIC_API_KEY environment variable\n2. Install dependencies: npm install ai @ai-sdk/anthropic"
  }
} 